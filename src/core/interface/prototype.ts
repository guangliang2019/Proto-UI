import { EventCommands } from './event';
import { Context, State } from './managers';
import { RendererAPI } from './renderer';

/**
 * 可以通过属性监听的类型
 */
export type AttributeValue = string | number | boolean;

export interface PrototypeAPI<Props = {}> {
  props: {
    /**
     * Define the default parameters of the component (generated by the prototype).
     * It can be redefined, with the latter overriding the former.
     * @param defaultProps default properties of the component
     */
    define: (defaultProps: Props) => void;
    /**
     * Set the properties of the component.
     * @param props properties of the component
     */
    set: (props: Partial<Props>) => void;
    /**
     * Get the properties of the component.
     * @returns properties of the component
     */
    get: () => Props;
    /**
     * Watch the properties of the component. When the properties change, the callback function will be called.
     * @param props properties of the component
     * @param callback callback function
     */
    watch: (props: (keyof Props)[], callback: (props: Props) => void) => void;
  };

  state: {
    /**
     * Define the state of the component.
     * @warning Do not use this method to define the state that is not related to the state machine of the interactive behavior or the rendering state. You can use common variables to store it instead.
     * @param initial initial value of the state
     * @param attributeName a name of the state, which will be used as the attribute name of the state on the element.
     * @param options options of the state
     * @returns state object
     */
    define: <T>(
      initial: T,
      attributeName?: string,
      options?: {
        serialize?: (value: T) => string;
        deserialize?: (value: string) => T;
      }
    ) => State<T>;
    /**
     * Watch the state of the component. When the state changes, the callback function will be called.
     * @warning This method is specifically designed to listen to states that cannot be controlled. Do not use it to listen to states that are entirely under your control, as it would make the code fragile.
     * @param state state object
     * @param callback callback function
     */
    watch: <T>(state: State<T>, callback: (oldValue: T, newValue: T) => void) => void;
  };

  event: EventCommands;

  view: {
    /**
     * Update the component manually.
     * @returns a promise that resolves when the component is updated
     */
    update: () => Promise<void>;
    /**
     * Force update the component manually.
     * @returns a promise that resolves when the component is updated
     */
    forceUpdate: () => Promise<void>;
    /**
     * Get the root element of the component. Can only be called after the component is mounted.
     * @returns the root element of the component
     */
    getElement: () => HTMLElement;
    /**
     * Insert the provided element at the same position in the element list.
     * @param list the list of elements to insert
     * @param element the element to insert, if not provided, will use the root element of the component
     * @param index the index of the element to insert, if not provided, will based on its position relative to the specified list of elements
     * @returns the index of the inserted element
     */
    insertElement: (list: HTMLElement[], element?: HTMLElement, index?: number) => number;
    /**
     * Compare the position of the provided element with the target element.
     * @param target the target element
     * @param element the element to compare, if not provided, will use the root element of the component
     * @returns A bitmask representing the positional relationship of elements.
     */
    compareElementPosition: (target: HTMLElement, element?: HTMLElement) => number;
  };

  lifecycle: {
    /**
     * Register a callback function that will be called when the component is created.
     * @param callback callback function
     */
    onCreated: (callback: () => void) => void;
    /**
     * Register a callback function that will be called when the component is mounted.
     * @param callback callback function
     */
    onMounted: (callback: () => void) => void;
    /**
     * Register a callback function that will be called when the component is updated.
     * @param callback callback function
     */
    onUpdated: (callback: () => void) => void;
    /**
     * Register a callback function that will be called when the component is before unmounted.
     * @param callback callback function
     */
    onBeforeUnmount: (callback: () => void) => void;
    /**
     * Register a callback function that will be called when the component is destroyed.
     * @param callback callback function
     */
    onBeforeDestroy: (callback: () => void) => void;
  };

  context: {
    /**
     * Provide a context.
     * @param context the signature of the context to provide
     * @param contextBuilder the builder of the context,
     */
    provide: <T>(context: Context<T>, contextBuilder: (update: UpdateContext<T>) => T) => void;
    /**
     * Watch a context.
     * @param context the signature of the context to watch
     * @param listener the listener of the context. You can choose not to provide any listener callbacks. By subscribing to a specified context without providing a listener callback, you can still retrieve the current value of the specified context at any time, but you will not receive update messages for the context.
     */
    watch: <T>(context: Context<T>, listener?: (value: T, changedKeys: string[]) => void) => void;
    /**
     * Get the value of a context. Make sure you have already **watched** to the context and there is a provider for the context at the outside of the component.
     * @param context the signature of the context to get
     * @returns the value of the context
     */
    get: <T>(context: Context<T>) => T;
  };

  role: {
    /**
     * Once a component is marked as a Trigger, all its interactive behaviors will be merged into the innermost Trigger in the continuous nesting. This is useful in focus and event management.
     *
     * For example, when `DialogTrigger` is nested inside `DropdownMenuTrigger`, which is nested inside `Button`, the behaviors of `DialogTrigger` and `DropdownMenuTrigger` will actually be merged into the innermost `Button`.
     */
    asTrigger: () => void;
  };
}

export interface UpdateContext<T> {
  (value: Partial<T>, notify?: boolean): void;
}

/**
 * 原型配置项
 */
export interface Prototype<
  Props extends {} = {},
  States extends {} = {},
  Actions extends {} = {},
  Exposes extends {} = {},
> {
  /** 组件名称 */
  name: string;
  /** 可观察的属性 */
  observedAttributes?: string[];

  /**
   * 设置函数
   */
  setup: (p: PrototypeAPI<Props>) => PrototypeSetupResult<States, Actions, Exposes> | void;
}

/**
 * 原型设置函数的返回值
 */
export interface PrototypeSetupResult<
  States extends {} = {},
  Actions extends {} = {},
  Exposes extends {} = {},
> {
  /**
   * 组件状态
   */
  states?: States;

  /**
   * 组件动作/方法
   */
  actions?: Actions;

  /**
   * 暴露给外部的接口
   */
  exposes?: Exposes;

  /**
   * 渲染函数
   */
  render?: (renderer: RendererAPI) => Element | void;
}

/**
 * 原型设置函数
 */
export type PrototypeSetup<
  Props extends {} = {},
  States extends {} = {},
  Actions extends {} = {},
  Exposes extends {} = {},
> = (p: PrototypeAPI<Props>) => PrototypeSetupResult<States, Actions, Exposes> | void;
