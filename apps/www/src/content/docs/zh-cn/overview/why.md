---
title: 为什么会有 Proto UI
description: 为什么组件生态需要一层独立于框架之外的语义层
---

## 我们正在用低效的方式对抗复杂度

前端生态并不缺框架，也不缺组件库。

React、Vue、Flutter、Web Components……  
每一种技术都有成熟的社区和丰富的实现。

问题不在于它们不好。

问题在于：  
当框架增加时，组件实现的数量会按乘法增长。

```

框架 × 设计语言 × 平台

```

一个 Button，在不同框架中往往需要分别实现。  
一个 Dialog，在 Web 与原生中可能要维护多套逻辑。

这不是某个框架的缺陷。  
这是结构性的重复。

我们正在用复制与重写来应对组合爆炸。

---

## 组件本身具备可抽象的主体

“组件”并不是某个框架的专属概念。

一个 Button 的核心语义包括：

- 接收输入  
- 响应点击  
- 触发事件  
- 管理状态  
- 提供可访问性语义  

这些行为并不天然属于 React 或 Vue。

它们属于交互语义。  
框架只是承载这种语义的宿主环境。

如果组件的交互语义可以被清晰描述，那么它理论上可以独立存在。

重复实现并不是唯一选择。

---

## Proto UI 的尝试

Proto UI 不打算成为新的框架。

它提出的是一种方法：

- 将组件的交互语义抽象为 **Prototype**
- 由 **Adapter** 或 **Compiler** 映射到具体宿主环境

换句话说：

> 组件的语义定义一次，实现可以变化。

这种分离不会消除框架。  
它只是为组件增加了一层独立的语义空间。

---

## 谁需要理解 Proto UI？

并不是所有人。

如果 Proto UI 发展健康：

- 大多数使用者只会使用现成原型  
- 一部分开发者会组合或扩展原型  
- 少数人参与协议层的演进  

Proto UI 的目标不是让更多人学习新的语法。

它更希望：

> 即使你从未接触过 Prototype，也能受益于它所带来的可迁移能力。

---

## 这不是对现有生态的否定

Radix UI、Headless UI、Base UI 等组件库在各自生态中做得很好。

Proto UI 试图解决的是另一类问题：

当设计语言与框架交叉时，  
如何避免重复实现相同的交互语义？

这是一个结构层面的问题。

Proto UI 只是提供了一种可能的答案。