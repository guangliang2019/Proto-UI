## Proto UI 在想什么？一条不那么绕的解释线路

在解释 Proto UI 之前，绕不开一个看似老生常谈、但实际上没人能回避的问题：

**组件化，到底在做什么？**

### 1. 组件的本质是什么？怎样才算一个“信息完备”的组件？

乍一看，“定义组件的本质”像是在故弄玄虚，但现实是：
**所有真正做过组件化的框架，都必须在某个层面回答这个问题**。

只不过它们给出的答案不一样：

- React 认为组件是一个渲染函数
- Vue 认为组件是模板结构 + 数据模型
- Flutter 认为组件是一个类
- 也有人认为组件是尚未编译的渲染操作、是静态结构、是配置树……

这些差异并不是偶然的，它们背后都隐含着一句话：

> “在这个体系里，我们认为这样定义组件，信息就已经足够了。”

Proto UI 给出的答案有点不一样，也更接近一种“鸭子类型”的思路：
**不追求组件在形式上是不是同一把钥匙，而追求它们能不能打开同一扇门。**

具体来说：

> 如果一个组件，能够对它的所有交互者，持续地、可预期地做出正确反应，
> 那么在 Proto UI 看来，它就是一个“合格的组件”。

换句话说，Proto UI 并不急着规定组件“长什么样”，
而是把注意力放在另一件事上：

> **一个组件，究竟需要描述多少交互，才算信息完备？**

因此，Proto UI 认为组件的（功能性）本质是：

> **组件与所有交互对象之间的“交互描述的总和”。**

这个定义的好处在于，它往往比具体框架中的组件定义**携带更多、也更保真的信息**。
而当你拥有一份足够保真的交互描述时，就可以把它**有损压缩**成不同平台、不同技术栈下的具体实现——
压缩的是实现细节，而不是交互语义本身。

---

### 2. 为什么 Proto UI 有这么多子 API？它们是怎么划分出来的？

第一次看到 Proto UI 的 API 列表时，很多人的直觉反应是：

> “怎么这么多？这谁记得住？”

但这个感觉其实来自一个错觉——
**这些 API 并不是从‘功能模块’的角度划分出来的，而是从‘信息如何流动’的角度。**

Proto UI 把这些 API 大类称为「信息通路」。

原因很简单：
组件之所以产生交互，是因为它在和不同的对象进行信息交换，而信息必须沿着某条路径流动。

只要换一个视角，事情就会清晰很多。

---

#### 组件的三类主要交互对象

Proto UI 默认考虑三种最核心的交互者：

1. **最终用户（User）**
2. **使用组件的人（App Maker）**
   比如开发者、设计师、应用构建者
3. **其他组件（Other Component）**

接下来，只需要问一个问题：

> 信息是**谁 → 组件**，还是**组件 → 谁**？

---

#### 于是信息通路自然出现了

- **组件 ↔ User**

  - User 向组件输入信息（点击、触摸、操作）：`event`
  - 组件向 User 输出信息（视觉、听觉、触觉反馈）：`feedback`

- **组件 ↔ App Maker**

  - App Maker 向组件输入配置与约束：`props`
  - 组件向 App Maker 暴露能力与状态：`expose`

- **组件 ↔ 组件**

  - 组件之间交换信息：`context`
    在理论上是双向的，在实践中常常以单向数据流实现

这样一来你会发现：

> Proto UI 的“多 API”，本质上只是把**通信对象 + 信息方向**这件事完整地枚举了一遍。

这也是为什么这些信息通路可以自由组合、彼此不依赖——
因为它们描述的是**不同的交流关系**，而不是彼此叠加的功能。

---

#### 那 lifecycle 和 state 又是什么？

还有一些 API，经常会被一起提起，但它们并不完全属于“信息通路”。

- **lifecycle**
  来自时间属性：程序总会开始、运行、结束，组件的能力也会随执行阶段生效或失效
  所以几乎所有信息通路，都会在某种程度上依赖 lifecycle

- **state**
  来自空间属性：内存、变量、状态机、本地持有的数据
  它不是在描述“谁和谁在交互”，而是在描述组件**作为一个存在体**所必须具备的内部条件

你可以减少 state 的使用方式，但你很难消除“空间属性”本身——
它只是是否被显式建模的问题。

---

### 一个简单的记忆方式

如果试图死记硬背所有 API 名字，确实会很痛苦。
但如果从“组件在和谁说话”这个角度去想，事情就会变得很直观：

- **User**
- **App Maker**
- **Other Component**

剩下的，只是信息在这三者之间**如何流动**的问题。

Proto UI 所做的，并不是发明更多 API，
而是尽可能保真地描述这些信息流动，并把它们拆解成可以组合、可以验证、也可以被压缩实现的交互通路。
